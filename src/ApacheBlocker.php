<?php

declare(strict_types=1);

namespace Webrium\XZeroProtect;

/**
 * Writes/removes banned IPs in .htaccess so Apache blocks them
 * before PHP is even invoked.
 */
class ApacheBlocker
{
    private const MARKER_START = '# xZeroProtect:start';
    private const MARKER_END   = '# xZeroProtect:end';

    private string $htaccessPath;

    public function __construct(string $htaccessPath)
    {
        $this->htaccessPath = $htaccessPath;
    }

    /**
     * Sync all active bans from Storage into .htaccess.
     */
    public function sync(array $bannedIps): void
    {
        $block = $this->buildBlock($bannedIps);
        $this->writeBlock($block);
    }

    /**
     * Add a single IP to .htaccess immediately.
     */
    public function block(string $ip): void
    {
        $existing = $this->readCurrentIps();
        $existing[$ip] = true;
        $this->sync(array_keys($existing));
    }

    /**
     * Remove a single IP from .htaccess.
     */
    public function unblock(string $ip): void
    {
        $existing = $this->readCurrentIps();
        unset($existing[$ip]);
        $this->sync(array_keys($existing));
    }

    /**
     * Remove the xZeroProtect block entirely from .htaccess.
     */
    public function clear(): void
    {
        $this->writeBlock('');
    }

    // -------------------------------------------------------------------------
    // Private helpers
    // -------------------------------------------------------------------------

    private function buildBlock(array $ips): string
    {
        if (empty($ips)) {
            return '';
        }

        $lines   = [];
        $lines[] = self::MARKER_START;
        $lines[] = '# Auto-generated by xZeroProtect â€” do not edit this block manually';
        $lines[] = '# Last updated: ' . date('Y-m-d H:i:s');
        $lines[] = '<RequireAll>';
        $lines[] = '    Require all granted';

        foreach ($ips as $ip) {
            $ip = trim($ip);
            if ($ip === '') continue;
            $lines[] = '    Require not ip ' . $ip;
        }

        $lines[] = '</RequireAll>';
        $lines[] = self::MARKER_END;

        return implode(PHP_EOL, $lines) . PHP_EOL;
    }

    private function readCurrentIps(): array
    {
        if (!file_exists($this->htaccessPath)) {
            return [];
        }

        $content = file_get_contents($this->htaccessPath);
        $ips     = [];

        if (preg_match_all('/Require not ip\s+(.+)/m', $content, $matches)) {
            foreach ($matches[1] as $ip) {
                $ips[trim($ip)] = true;
            }
        }

        return $ips;
    }

    private function writeBlock(string $newBlock): void
    {
        $existing = file_exists($this->htaccessPath)
            ? file_get_contents($this->htaccessPath)
            : '';

        // Remove old block
        $pattern = '/' . preg_quote(self::MARKER_START, '/') . '.*?' . preg_quote(self::MARKER_END, '/') . '\s*/s';
        $cleaned = preg_replace($pattern, '', $existing);

        $final = rtrim($cleaned ?? '') . PHP_EOL . PHP_EOL . $newBlock;

        file_put_contents($this->htaccessPath, $final, LOCK_EX);
    }
}
